1. **KISS (Keep It Simple, Stupid)**

Strive for simplicity in design and implementation
Avoid unnecessary complexity that can hinder understanding and maintainability
Focus on creating clean, readable, and concise code
2. **DRY (Don’t Repeat Yourself)**

Eliminate redundancy in code and processes
Promote code reuse and modular design to improve efficiency and reduce errors
Centralize common functionalities and avoid duplication
3. **YAGNI (You Aren’t Gonna Need It)**

Implement features that are currently required and avoid over-engineering
Resist the temptation to add unnecessary functionality that may never be used
Focus on delivering value incrementally and iteratively
4. **Separation of Concerns**

Divide software into distinct, independent modules or components
Each module should have a clear responsibility and minimal overlap with others
Promote loose coupling and high cohesion for maintainability and scalability
5. **Modularity**

Design software as a collection of interchangeable, reusable modules
Encapsulate related functionalities into self-contained units
Enable easy modification, testing, and replacement of individual modules
6. **Single Responsibility Principle (SRP)**

Each module, class, or function should have a single, well-defined responsibility
Avoid mixing multiple concerns within a single unit of code
Facilitate understanding, testing, and maintenance of the codebase
7. **Open-Closed Principle (OCP)**

Software entities should be open for extension but closed for modification
Encourage the use of abstractions and interfaces to enable extensibility
Minimize the impact of changes on existing code
8. **Liskov Substitution Principle (LSP)**

Subtypes should be substitutable for their base types without affecting correctness
Ensure that derived classes adhere to the contract of their parent classes
Maintain behavioral consistency and avoid unexpected side effects
9. **Interface Segregation Principle (ISP)**

Clients should not be forced to depend on interfaces they do not use
Split large interfaces into smaller, more specific ones
Promote loose coupling and improve modularity
10. **Dependency Inversion Principle (DIP)**

High-level modules should depend on abstractions, not concrete implementations
Invert the dependency flow to make code more flexible and testable
Utilize dependency injection and interfaces to decouple modules